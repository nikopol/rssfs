(ns rssfs.core
  (:require [rssfs.logger :as log]
            [clj-rss.core :as rss]
            [clojure.string :as str]
            [clojure.java.io :as io]
            [clojure.tools.cli :refer [parse-opts]])
  (:use [clojure.pprint :only [pprint]])
  (:gen-class))


(def VERSION "0.1")


(defn readable-size
  [size]
  (cond
    (< size 2048)          (str size)
    (< size 1024000)       (format "%.0fk" (Math/floor (/ size 1024)))
    (< size 1024000000)    (format "%.0fM" (Math/floor (/ size 1024000)))
    (< size 1024000000000) (format "%.1fG" (Math/floor (/ size 1024000000)))
    :else                  (format "%.1fT" (Math/floor (/ size 1024000000000)))))


(defn scandir
  [opt]
  (let [{:keys [path mode category mask]} opt
        dir (io/file path)
        rex (re-pattern (if mask mask "(?i)^[^\\.].*"))
        files (filter #(and (or (and (= mode "dir") (.isDirectory %))
                                (and (= mode "file") (.isFile %)))
                            (not (.isHidden %))
                            (re-matches rex (.getName %))) 
                      (file-seq dir))]
    (log/debug "scan " (.getAbsoluteFile dir) " : " (count files) " items")
    (map (fn[f] {:name (.getName f)
                 :path (.getPath f)
                 :dir? (.isDirectory f)
                 :date (.lastModified f)
                 :category category
                 :size (.length f)})
         files)))


(defn scandirs
  [cfg]
  (let [paths (:paths cfg)]
    (log/debug (count paths) " dirs to scan")
    (apply concat (map scandir paths))))
                        

(defn most-recents
  [nb files]
  (log/debug "sorting " (count files) " items")
  (take nb (sort-by :date > files)))


(defn make-rss
  [cfg files]
  (log/debug "build " (count files) " rss items")
  (let [items (map (fn [item] {:title (str (:name item) " (" (:category item) "/" (readable-size (:size item)) ")")
                               :pubDate (java.util.Date. (:date item))
                               :description (str "path: " (:path item) \newline "size: " (:size item))
                               :author (:author cfg)
                               :category (:category item)})
                   files)]
    (rss/channel-xml {:title (:title cfg) 
                      :link (:link cfg)
                      :description (:description cfg)}
                     items)))


(defn help
  [options-summary]
  (->> [(str "RSS-FS v" VERSION)
        "generate a rss with the most recents files in the given path[s]\n"
        "syntax:"
        "rssls [path] [options]\n"
        "by defaut current path is used\n"
        "options:"
        options-summary]
       (str/join \newline)))


(def cli-options
  [["-s" "--size int"      "rss items count" :default 20 :parse-fn #(Integer/parseInt %)]
   ["-o" "--output file"   "write rss in the given file"]
   ["-c" "--conf file"     "config file"]
   ["-v" "--verbose"       "more blah blah"]
   ["-d" "--dump"          "debug dump"]
   ["-h" "--help"]])


(defn exit!
  [status & msg]
  (println (apply str msg))
  (System/exit status))


(defn -main 
  [& args]
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)
        cfg-file (:conf options)
        path (first arguments)]
    (when (:verbose options)
      (log/set-level! :debug))
    (log/debug "RSS-FS v" VERSION)
    (cond
      (:help options) (exit! 1 (help summary))
      (and cfg-file (not (.exists (io/as-file cfg-file)))) (exit! 3 "file " cfg-file " not found")
      errors (exit! 4 (str/join \newline errors)))
    (let [cfg (merge {:title "RSS Files"
                      :link "http://localhost"
                      :description (str "generated by RSS-FS v" VERSION)
                      :author "rssfs"}
                     (if cfg-file 
                       (load-file cfg-file)
                       {:paths [{:path (if path path ".") :mode "file" :category "localdir"}]}))
          files (most-recents (:size options) (scandirs cfg))
          out-file (:output options)
          out (make-rss cfg files)]
      (if (:dump options)
        (pprint list)
        (if out-file
          (do
            (log/debug "writing " out-file)
            (spit out-file out))
          (println out))))))
